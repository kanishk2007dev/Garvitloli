<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Winter Subway Runner 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 4px #000;
            font-weight: 900;
            font-size: 24px;
        }
        .score-box, .coin-box {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        .coin-icon {
            color: #FFD700;
            font-size: 28px;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            color: white;
            z-index: 10;
            text-align: center;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-style: italic;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        .btn {
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 0 #1B5E20;
            transition: transform 0.1s;
            margin-top: 20px;
        }
        .btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }
        #instructions {
            margin-top: 20px;
            font-size: 16px;
            color: #ddd;
            text-align: center;
            line-height: 1.5;
        }
        .hidden {
            display: none !important;
        }
        
        .birthday-img {
            max-width: 80%;
            max-height: 50vh;
            border-radius: 15px;
            border: 4px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            margin: 15px 0;
            object-fit: contain;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .birthday-title {
            color: #FFD700 !important;
            text-shadow: 0 0 15px #FF4500 !important;
            font-size: 3rem !important;
            margin-bottom: 5px !important;
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 100;
        }

        @media (max-width: 768px) {
            h1 { font-size: 32px; }
            .hud-top { padding: 10px; font-size: 18px; }
            .birthday-title { font-size: 2rem !important; }
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    <div id="loading">Loading High-Res Assets...</div>

    <div id="ui-layer" class="hidden">
        <div class="hud-top">
            <div class="score-box">
                <span>SCORE</span>
                <span id="score-display">0</span>
            </div>
            <div class="coin-box">
                <span class="coin-icon">‚óè</span>
                <span id="coin-display">0</span>
            </div>
        </div>
    </div>

    <div id="start-screen" class="hidden">
        <h1>Garvit's Run</h1>
        <p style="font-size: 1.2rem; color: #add8e6;">3D Endless Runner</p>
        <div id="instructions">
            Desktop: Arrow Keys / WASD to Move & Jump<br>
            Mobile: Swipe to Move & Jump
        </div>
        <button class="btn" id="start-btn">TAP TO PLAY</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 class="birthday-title">Happy Birthday<br>Dear Garvit! üéâ</h1>
        
        <img src="https://raw.githubusercontent.com/kanishk2007dev/kanishk/refs/heads/main/IMG-20251126-WA0070.jpg" 
             alt="Happy Birthday Garvit" 
             class="birthday-img">
             
        <div style="font-size: 24px; margin-bottom: 10px; color: #fff;">Final Score: <span id="final-score">0</span></div>
        <button class="btn" id="restart-btn">PLAY AGAIN</button>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game Constants ---
        const LANE_WIDTH = 3.5;
        const GRAVITY = -0.6;
        const JUMP_FORCE = 0.6; 
        const SPEED_BASE = 0.015;
        const SPEED_INC = 0.000005; 
        
        // --- Audio Assets ---
        const bgMusic = new Audio('https://github.com/kanishk2007dev/Garvitloli/raw/refs/heads/main/ReelAudio-13417.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.5;

        const gameOverSound = new Audio('https://github.com/kanishk2007dev/Garvitloli/raw/refs/heads/main/ReelAudio-48421.mp3');
        gameOverSound.volume = 1.0;

        // --- Global Variables ---
        let scene, camera, renderer;
        let player;
        let worldChunkGroup;
        let obstacles = [];
        let coins = [];
        let isGameRunning = false;
        let gameSpeed = SPEED_BASE;
        let score = 0;
        let coinCount = 0;
        let backgroundTexture;
        let playerTexture;
        let playerAspectRatio = 1.0;

        // Player State
        let currentLane = 0; 
        let targetX = 0;
        let verticalVelocity = 0;
        let isJumping = false;
        let isDead = false;

        // Assets/Materials
        const materials = {};

        function init() {
            // Setup Scene
            scene = new THREE.Scene();
            // Lighter fog for better visibility of background
            scene.fog = new THREE.FogExp2(0x111111, 0.015); 

            // Setup Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 2, 0);

            // Setup Renderer (High Quality)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding; // Critical for correct colors
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Face Light (Keeps character face lit)
            const faceLight = new THREE.PointLight(0xffffff, 0.5, 10);
            faceLight.position.set(0, 3, 5);
            scene.add(faceLight); // Add to scene, player will move through it, or add to player group

            // Load Textures
            const loader = new THREE.TextureLoader();
            const bgUrl = 'https://raw.githubusercontent.com/kanishk2007dev/kanishk/refs/heads/main/IMG-20251213-WA0000.jpg';
            const playerUrl = 'https://raw.githubusercontent.com/kanishk2007dev/Garvitloli/refs/heads/main/IMG-20251215-WA0012.jpg';

            let loadedCount = 0;
            const checkLoad = () => {
                loadedCount++;
                if (loadedCount >= 2) initGame();
            };

            loader.load(bgUrl, (texture) => {
                backgroundTexture = texture;
                backgroundTexture.encoding = THREE.sRGBEncoding;
                backgroundTexture.minFilter = THREE.LinearFilter;
                
                // Create a giant sphere for the background (Skybox)
                const geometry = new THREE.SphereGeometry(500, 60, 40);
                geometry.scale(-1, 1, 1); // Invert normals
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                
                checkLoad();
            }, undefined, checkLoad);

            loader.load(playerUrl, (texture) => {
                playerTexture = texture;
                playerTexture.encoding = THREE.sRGBEncoding;
                playerTexture.minFilter = THREE.LinearFilter;
                playerTexture.magFilter = THREE.LinearFilter;
                
                // Calculate aspect ratio so the face isn't stretched
                if (texture.image) {
                    playerAspectRatio = texture.image.width / texture.image.height;
                }
                
                checkLoad();
            }, undefined, checkLoad);
        }

        function initGame() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');

            initMaterials();
            createPlayer();
            createEnvironment();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown);
            setupTouchControls();

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);

            renderer.render(scene, camera);
        }

        function initMaterials() {
            // --- Custom Shader Material for Player ---
            // Adjusted threshold and softness for better face preservation
            const uniforms = {
                uTexture: { value: playerTexture }
            };

            materials.playerShader = new THREE.ShaderMaterial({
                uniforms: uniforms,
                transparent: true,
                side: THREE.DoubleSide,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTexture;
                    varying vec2 vUv;
                    void main() {
                        vec4 color = texture2D(uTexture, vUv);
                        
                        // Calculate brightness
                        float brightness = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        
                        // Soft edge thresholding
                        // Lowered threshold to 0.05 to keep hair and eyes
                        // Smoothstep creates a soft fade instead of harsh jagged pixels
                        float alpha = smoothstep(0.05, 0.2, brightness); 
                        
                        gl_FragColor = vec4(color.rgb, alpha);
                    }
                `
            });

            materials.ground = new THREE.MeshStandardMaterial({ 
                color: 0xeeeeee, 
                roughness: 0.8,
                metalness: 0.1
            });
            
            materials.rail = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
            materials.wood = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 });
            
            materials.coin = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, 
                metalness: 1.0, 
                roughness: 0.1,
                emissive: 0x332200
            });
            
            // Train materials
            materials.train = new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.4, metalness: 0.3 });
            materials.train2 = new THREE.MeshStandardMaterial({ color: 0xb71c1c, roughness: 0.4, metalness: 0.3 });
            
            materials.barrier = new THREE.MeshStandardMaterial({ color: 0xe65100, roughness: 0.8 });
        }

        function createPlayer() {
            player = new THREE.Group();

            // Calculate dimensions based on aspect ratio
            // Fix height to 2.5, adjust width dynamically
            const height = 2.5;
            const width = height * playerAspectRatio;

            const charGeo = new THREE.PlaneGeometry(width, height);
            const charMesh = new THREE.Mesh(charGeo, materials.playerShader);
            charMesh.position.y = 1.5; 
            // charMesh.castShadow = true; // Planes casting shadow can look weird with transparent textures
            player.add(charMesh);

            // Hoverboard
            const boardGeo = new THREE.BoxGeometry(1.6, 0.1, 2.5);
            const board = new THREE.Mesh(boardGeo, new THREE.MeshStandardMaterial({
                color: 0xff00ff, 
                metalness: 0.5, 
                roughness: 0.2,
                emissive: 0x220022
            }));
            board.position.y = 0.1;
            player.add(board);

            // Personal Player Light (Illuminates the face card)
            const playerLight = new THREE.PointLight(0xffffff, 0.8, 5);
            playerLight.position.set(0, 1, 2);
            player.add(playerLight);

            scene.add(player);
        }

        function createEnvironment() {
            worldChunkGroup = new THREE.Group();
            scene.add(worldChunkGroup);

            // Initial ground generation
            for (let i = 0; i < 20; i++) {
                spawnWorldChunk(-10 + (i * 10));
            }
        }

        function spawnWorldChunk(zPosition) {
            const chunk = new THREE.Group();
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(30, 10);
            const ground = new THREE.Mesh(groundGeo, materials.ground);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            chunk.add(ground);

            // Tracks
            createTracks(chunk);
            
            chunk.position.z = zPosition;
            worldChunkGroup.add(chunk);
        }

        function createTracks(group) {
            [-LANE_WIDTH, 0, LANE_WIDTH].forEach(x => {
                // Rails
                const railGeo = new THREE.BoxGeometry(0.15, 0.1, 10);
                const railLeft = new THREE.Mesh(railGeo, materials.rail);
                railLeft.position.set(x - 0.6, 0.05, 0);
                railLeft.receiveShadow = true;
                group.add(railLeft);
                
                const railRight = new THREE.Mesh(railGeo, materials.rail);
                railRight.position.set(x + 0.6, 0.05, 0);
                railRight.receiveShadow = true;
                group.add(railRight);

                // Ties
                for(let i=0; i<5; i++) {
                    const tieGeo = new THREE.BoxGeometry(2.2, 0.1, 0.5);
                    const tie = new THREE.Mesh(tieGeo, materials.wood);
                    tie.position.set(x, 0.02, -4 + (i*2));
                    tie.receiveShadow = true;
                    group.add(tie);
                }
            });
        }

        // --- Game Logic ---

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            score = 0;
            coinCount = 0;
            gameSpeed = SPEED_BASE;
            isGameRunning = true;
            isDead = false;

            bgMusic.currentTime = 0;
            bgMusic.play().catch(e => console.log("Audio play failed:", e));
            gameOverSound.pause();
            gameOverSound.currentTime = 0;

            animate();
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            
            obstacles.forEach(o => scene.remove(o));
            coins.forEach(c => scene.remove(c));
            obstacles = [];
            coins = [];
            
            player.position.set(0, 0, 0);
            currentLane = 0;
            targetX = 0;
            
            startGame();
        }

        function spawnObstacle() {
            const lane = Math.floor(Math.random() * 3) - 1; 
            const xPos = lane * LANE_WIDTH;
            const zPos = -200; // Spawn much further away

            const type = Math.random();
            let obs;

            if (type < 0.3) {
                // Barrier
                const geo = new THREE.BoxGeometry(2.5, 1.5, 0.5);
                obs = new THREE.Mesh(geo, materials.barrier);
                obs.position.set(xPos, 0.75, zPos);
                obs.castShadow = true;
                obs.userData = { hitBox: {w: 2, h: 1.5, d: 0.5} };
            } else if (type < 0.6) {
                // SUPER LONG TRAIN
                const trainLength = 50; // Increased length significantly
                const geo = new THREE.BoxGeometry(2.9, 4.5, trainLength);
                const mat = Math.random() > 0.5 ? materials.train : materials.train2;
                obs = new THREE.Mesh(geo, mat);
                obs.position.set(xPos, 2.25, zPos);
                obs.castShadow = true;
                obs.userData = { hitBox: {w: 2.5, h: 4, d: trainLength - 1} }; 

                // Train details (lights)
                const lightGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2);
                const lightMat = new THREE.MeshBasicMaterial({color: 0xffffaa});
                
                const l1 = new THREE.Mesh(lightGeo, lightMat);
                l1.rotation.x = Math.PI/2;
                l1.position.set(0.8, -1, trainLength/2);
                obs.add(l1);
                
                const l2 = l1.clone();
                l2.position.set(-0.8, -1, trainLength/2);
                obs.add(l2);

            } else {
                // Tall Pillar
                const geo = new THREE.BoxGeometry(2, 8, 2);
                obs = new THREE.Mesh(geo, materials.wood);
                obs.position.set(xPos, 4, zPos);
                obs.castShadow = true;
                obs.userData = { hitBox: {w: 1.8, h: 8, d: 1.8} };
            }

            scene.add(obs);
            obstacles.push(obs);

            // Spawn Coins
            if (Math.random() > 0.3) {
                 const coinLane = (lane + 1) % 3 === 0 ? lane -1 : lane + 1;
                 spawnCoins(coinLane * LANE_WIDTH, zPos);
            }
        }

        function spawnCoins(x, startZ) {
            for(let i=0; i<8; i++) {
                const geo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                geo.rotateZ(Math.PI/2);
                const coin = new THREE.Mesh(geo, materials.coin);
                coin.position.set(x, 1, startZ - (i*3));
                scene.add(coin);
                coins.push(coin);
            }
        }

        // Input Handling
        function handleKeyDown(e) {
            if (!isGameRunning || isDead) return;

            if (e.key === 'ArrowLeft' || e.key === 'a') changeLane(-1);
            if (e.key === 'ArrowRight' || e.key === 'd') changeLane(1);
            if ((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') && !isJumping) jump();
        }

        function changeLane(dir) {
            const nextLane = currentLane + dir;
            if (nextLane >= -1 && nextLane <= 1) {
                currentLane = nextLane;
                targetX = currentLane * LANE_WIDTH;
            }
        }

        function jump() {
            if (!isJumping) {
                verticalVelocity = JUMP_FORCE;
                isJumping = true;
            }
        }

        // Touch Controls
        let touchStartX = 0;
        let touchStartY = 0;
        function setupTouchControls() {
            document.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, {passive: false});

            document.addEventListener('touchend', e => {
                if (!isGameRunning || isDead) return;
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (Math.abs(diffX) > 30) {
                        if (diffX > 0) changeLane(1);
                        else changeLane(-1);
                    }
                } else {
                    if (diffY < -30 && !isJumping) jump();
                }
            }, {passive: false});
        }

        function gameOver() {
            isGameRunning = false;
            isDead = true;

            bgMusic.pause();
            gameOverSound.currentTime = 0;
            gameOverSound.play().catch(e => console.log("Game Over sound failed:", e));

            document.getElementById('final-score').innerText = Math.floor(score);
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function animate() {
            if (!isGameRunning) return;
            
            requestAnimationFrame(animate);
            gameSpeed += SPEED_INC;

            // Player Animation
            player.position.x += (targetX - player.position.x) * 0.15;
            player.rotation.z = (targetX - player.position.x) * -0.1;
            player.rotation.x = isJumping ? -0.2 : 0; 
            
            // Subtle bobbing for "Running" effect
            if (!isJumping) {
                player.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.1;
            }

            if (isJumping) {
                player.position.y += verticalVelocity;
                verticalVelocity += GRAVITY * 0.05; 

                if (player.position.y <= 0) {
                    player.position.y = 0;
                    isJumping = false;
                    verticalVelocity = 0;
                }
            }

            const moveSpeed = gameSpeed * 20;

            // Environment
            worldChunkGroup.children.forEach(chunk => {
                chunk.position.z += moveSpeed;
                if (chunk.position.z > 20) {
                    chunk.position.z -= 200; 
                }
            });

            // Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.position.z += moveSpeed;

                const pBox = new THREE.Box3().setFromObject(player);
                // Adjust hitbox for the flat plane character
                pBox.min.x += 0.5; pBox.max.x -= 0.5;
                pBox.min.y += 0.2; pBox.max.y -= 0.2;
                pBox.min.z += 0.2; pBox.max.z -= 0.2;

                const oBox = new THREE.Box3().setFromObject(obs);
                
                if (pBox.intersectsBox(oBox)) {
                    gameOver();
                }

                if (obs.position.z > 50) { // Despawn much later
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                }
            }

            // Coins
            for (let i = coins.length - 1; i >= 0; i--) {
                let coin = coins[i];
                coin.position.z += moveSpeed;
                coin.rotation.y += 0.1;

                if (player.position.distanceTo(coin.position) < 2.0) { // Increased pickup range
                    scene.remove(coin);
                    coins.splice(i, 1);
                    coinCount++;
                    score += 100;
                    document.getElementById('coin-display').innerText = coinCount;
                } else if (coin.position.z > 15) {
                    scene.remove(coin);
                    coins.splice(i, 1);
                }
            }

            if (Math.random() < 0.015 + (gameSpeed * 0.01)) { 
                const lastObs = obstacles[obstacles.length-1];
                if (!lastObs || lastObs.position.z > -80) { // Keep spacing for long trains
                     spawnObstacle();
                }
            }

            score += gameSpeed * 10;
            document.getElementById('score-display').innerText = Math.floor(score).toString().padStart(6, '0');

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
  </html>
